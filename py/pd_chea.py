# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <codecell>

sys.path.append("/data/adrian/code/projects/broad/")
import pandas as pd
import pd_analysis as pda
#import alib.plots
import pandasql
import cPickle
import psycopg2
import alib.plots

# <codecell>


# <codecell>

class GZWorkNode():
    pass

class GZWorkFlow():
    pass

class GZWorkRunner():
    pass

# <codecell>


# <codecell>

conn = psycopg2.connect(database="mousegenome", user="adrian", password="adrian", host="localhost")

# <codecell>

class LoadGeneMotifs(GZWorkNode):
    inputs = ["conn"]
    outputs = ["mm9_gene_motifs"]
    
    def run(self, conn):
        result = {}
        import pandas.io.sql as sql
        cur = conn.cursor()
        result["mm9_gene_motifs"] = sql.read_frame("select * from mm9_gene_motifs_distinct where max_motif_score >= 0.7", conn)
        return result

# <codecell>

class WideLoad(GZWorkNode):
    inputs = []
    outputs = ["cp_both_wide_info"]
    
    
    def run():
        # load amalgamated table of statistics by probeset from pickled pandas file.  This file was generated by the pd_calc_stats notebook or script
        result["cp_both_wide_info"] = cPickle.load( open("/data/adrian/Dropbox/Projects/Broad/PD_mouse/results/2013_july_9/cp_both_wide_info.pandas.pickle") )
        return result
    

# <codecell>

class GetFactorTypes(GZWorkNode):
    inputs = ["cp_both_wide_info"]
    outputs = ["factortypes"]

    def run(cp_both_wide_info):
        factortypes = {}
        for c in cp_both_wide_info.drop(["probe_id", "symbol", "gene_name"], axis=1).columns:
            for (k, v) in dict(pda.tm.d(c)).items():
                if isinstance(k, list):
                    k = tuple(k)
                if isinstance(v, list):
                    v = tuple(v)
                if factortypes.has_key(k):
                    factortypes[k].add(v)
                else:
                    factortypes[k] = set([v])

# <codecell>

def getContrasts(x):
    res = {}
#    print x
    for fc_threshold in [1.5]:
        for comparison in factortypes["cmp"]:
            for celltype in factortypes["ct"]:
                #print comparison
                test_query = test_info + [ ["cmp", list(comparison)] ] + [ ["ct", celltype] ]
                fc_query = fc_info + [ ["cmp", list(comparison)] ] + [ ["ct", celltype] ]
                #td = dict(tm.d(c))
                if pda.tm.e(test_query) in set(cp_both_wide_info.columns):
#                    print pda.tm.e(test_query), pda.tm.e(fc_query)
                    res[pda.tm.e(fc_query)] = int((x[ pda.tm.e(test_query) ] < 0.10)) * x[ pda.tm.e(fc_query) ] * int(abs(x[pda.tm.e(fc_query)]) > log2(fc_threshold))
    return pd.Series(res)
#                current_group = cp_both_wide_info.select(
#                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
#                              and abs(cp_both_wide_info.ix[x, pda.tm.e(fc_query) ]) >= log2(fc_threshold)
#                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]] 

# <codecell>

patternGroups = sign( activePatterns ).groupby( list(activePatterns.columns), axis=0 )

# <codecell>

alib.plots.clusterHeatmap( pd.DataFrame( patternGroups.groups.keys(), columns=activePatterns.columns), 
                          "", None, None, width=6, height=15,
                          cluster_rows= True, cluster_columns=True, distmethod='correlation')

# <codecell>

contrastPatterns = cp_both_wide_info.apply( getContrasts, axis=1 )

# <codecell>

activePatterns = contrastPatterns.select( lambda x: contrastPatterns.ix[x, :].abs().sum() > 0 ) 

# <codecell>

figsize(10, 40)
alib.plots.clusterHeatmap(activePatterns[0:300], "", None, None, height=150, width=8,
                          cluster_rows=True, cluster_columns=True,
                          distmethod='euclidean')

# <codecell>

getContrasts(cp_both_wide_info.ix[cp_both_wide_info.index[3], :])

# <codecell>

test_info = [["mc", "bh"], ["st", "pval"], ["tt", "welch ttest"]]
fc_info = [["st", "fc_medians"]]

# <codecell>

test_info = [["mc", "bh"], ["st", "pval"], ["tt", "welch ttest"]]
fc_info = [["st", "fc_medians"]]
fc_threshold = log2(1.5)

summary = {}
top_tfs = {}

for fc_threshold in [1.5]:
    for comparison in factortypes["cmp"]:
        for celltype in factortypes["ct"]:
            #print comparison
            test_query = test_info + [ ["cmp", list(comparison)] ] + [ ["ct", celltype] ]
            fc_query = fc_info + [ ["cmp", list(comparison)] ] + [ ["ct", celltype] ]
            #td = dict(tm.d(c))
            if pda.tm.e(test_query) in set(cp_both_wide_info.columns):
                print pda.tm.e(test_query)
                current_group = cp_both_wide_info.select(
                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
                              and abs(cp_both_wide_info.ix[x, pda.tm.e(fc_query) ]) >= log2(fc_threshold)
                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]] 
                k = pda.tm.e([ ["cmp", list(comparison)] ] 
                                 + [ ["ct", celltype] ]
                                 + [ ["dir", "any"]])
                try:
                    top_tfs[k] = getTFMatches( current_group, 1)
                except:
                    top_tfs[k] = None
                
                
                current_group = cp_both_wide_info.select(
                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
                              and cp_both_wide_info.ix[x, pda.tm.e(fc_query) ] >= log2(fc_threshold)
                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]]  
                k = pda.tm.e([ ["cmp", list(comparison)] ] 
                                 + [ ["ct", celltype] ]
                                 + [ ["dir", "up"]])                
                
                try:
                    top_tfs[ k ] = getTFMatches( current_group, 1)
                except:
                    top_tfs[ k ] = None

                    
                current_group = cp_both_wide_info.select(
                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
                              and cp_both_wide_info.ix[x, pda.tm.e(fc_query) ] <= -log2(fc_threshold)
                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]] 
                k = pda.tm.e([ ["cmp", list(comparison)] ] 
                                 + [ ["ct", celltype] ]
                                 + [ ["dir", "down"]])                
                try:
                    top_tfs[ k ] = getTFMatches( current_group, 1)
                except:
                    top_tfs[ k ] = None
                    
                
#                summary[ (celltype, comparison, fc_threshold, "changed") ] = len(uniqueSym( cp_both_wide_info.select(
#                        lambda x: cp_both_wide_info.ix[x, tm.e(test_query) ] < 0.10
#                              and abs(cp_both_wide_info.ix[x, tm.e(fc_query) ]) >= log2(fc_threshold)
#                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) ).symbol ))
#                summary[ (celltype, comparison, fc_threshold, "up") ] = len(uniqueSym( cp_both_wide_info.select(
#                        lambda x: cp_both_wide_info.ix[x, tm.e(test_query) ] < 0.10
#                              and cp_both_wide_info.ix[x, tm.e(fc_query) ] >= log2(fc_threshold)
#                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) ).symbol ))
#                summary[ (celltype, comparison, fc_threshold, "down") ] = len(uniqueSym( cp_both_wide_info.select(
#                        lambda x: cp_both_wide_info.ix[x, tm.e(test_query) ] < 0.10
#                              and cp_both_wide_info.ix[x, tm.e(fc_query) ] <= -log2(fc_threshold)
#                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) ).symbol ))
            else:
                print "--"

# <codecell>

test_info = [["mc", "bh"], ["st", "pval"], ["tt", "welch ttest"]]
fc_info = [["st", "fc_medians"]]
fc_threshold = log2(1.5)

summary = {}
top_motifs = {}

for fc_threshold in [1.5]:
    for comparison in factortypes["cmp"]:
        for celltype in factortypes["ct"]:
            #print comparison
            test_query = test_info + [ ["cmp", list(comparison)] ] + [ ["ct", celltype] ]
            fc_query = fc_info + [ ["cmp", list(comparison)] ] + [ ["ct", celltype] ]
            #td = dict(tm.d(c))
            if pda.tm.e(test_query) in set(cp_both_wide_info.columns):
                print pda.tm.e(test_query)
                current_group = cp_both_wide_info.select(
                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
                              and abs(cp_both_wide_info.ix[x, pda.tm.e(fc_query) ]) >= log2(fc_threshold)
                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]]
                k = pda.tm.e([ ["cmp", list(comparison)] ] 
                                 + [ ["ct", celltype] ]
                                 + [ ["dir", "any"]])
                try:
                    top_motifs[k] = getMotifMatches( current_group, 1)
                except:
                    top_motifs[k] = None
                
                
                current_group = cp_both_wide_info.select(
                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
                              and cp_both_wide_info.ix[x, pda.tm.e(fc_query) ] >= log2(fc_threshold)
                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]]  
                k = pda.tm.e([ ["cmp", list(comparison)] ] 
                                 + [ ["ct", celltype] ]
                                 + [ ["dir", "up"]])                
                
                try:
                    top_motifs[ k ] = getMotifMatches( current_group, 1)
                except:
                    top_motifs[ k ] = None

                    
                current_group = cp_both_wide_info.select(
                        lambda x: cp_both_wide_info.ix[x, pda.tm.e(test_query) ] < 0.10
                              and cp_both_wide_info.ix[x, pda.tm.e(fc_query) ] <= -log2(fc_threshold)
                                and isinstance(cp_both_wide_info.ix[x, "symbol" ], str) )[["probe_id", "symbol",pda.tm.e(test_query), pda.tm.e(fc_query)]]  
                k = pda.tm.e([ ["cmp", list(comparison)] ] 
                                 + [ ["ct", celltype] ]
                                 + [ ["dir", "down"]])                
                try:
                    top_motifs[ k ] = getMotifMatches( current_group, 1)
                except:
                    top_motifs[ k ] = None
                    

# <codecell>

ks = top_tfs.keys()
ks.sort()
for k in ks:
    print k
    if top_tfs[k] is None:
        print "n/a"
    else:
        print top_tfs[k][0:10]

# <codecell>

import scipy.stats

# <codecell>

scipy.stats.hypergeom.sf( 33, 22000, 5042, 70) 

# <codecell>

total_genes = 22000

# <codecell>



p = overlaps.apply( lambda x: (
      scipy.stats.hypergeom.sf(
          x.ix["match_count"]-1, # number of differentially expressed genes in set
          total_genes,           # total number of genes
          x.ix["size of set"],   # number of genes in current set
          len( test_set ))),     # total number of genes in test set
                               axis=1)
    p = pd.DataFrame(p, columns=["hypergeom p-val"])

# <codecell>

top_motifs[k]

# <codecell>

for k in top_motifs.keys():
    if top_motifs[k] is not None and len(top_motifs[k].index) > 0:
        print k
        print top_motifs[k].drop("motif_occurrences", axis=1).merge(mm9_motif_gene_counts, 
                                                left_on="motif_name", 
                                                right_index=True).sort_index(by="pval", ascending=True)[0:20]

# <codecell>

top_tfs.items()[0]

# <codecell>

for k in top_tfs.keys():
    if top_tfs[k] is not None:
        top_tfs[k]["pval"] = top_tfs[k].merge(tf_target_counts, left_on="tf_name", right_index=True).apply( lambda x: (
         scipy.stats.hypergeom.sf(
              x.ix["count"]-1, # number of differentially expressed genes in set
              total_genes,           # total number of genes
              x.ix["chea_target_count"],   # number of genes in current set
              x.ix["total_genes_in_group"])),     # total number of genes in test set
            axis=1 )

# <codecell>

import scipy.stats
total_genes = 22000

# <codecell>

for k in top_motifs.keys():
    if top_motifs[k] is not None and len(top_motifs[k].index) > 0:
        top_motifs[k]["pval"] = top_motifs[k].merge(mm9_motif_gene_counts, left_on="motif_name", right_index=True).apply( lambda x: (
         scipy.stats.hypergeom.sf(
              x.ix["count"]-1, # number of differentially expressed genes in set
              total_genes,           # total number of genes
              x.ix["motif_gene_count"],   # number of genes in current set
              x.ix["total_genes_in_group"])),     # total number of genes in test set
            axis=1 )

# <codecell>

top_tfs.items()[0]

# <codecell>

"_".join( [str(z[1]) for z in pda.tm.d(k)] )

# <codecell>

e = pd.ExcelWriter("/data/adrian/Dropbox/pd_tf_enrichment_20130820.xls")

# <codecell>

e = open("/data/adrian/Dropbox/ptables/pd_tf_enrichment_20130822.html","w")

# <codecell>

out_path = "/data/adrian/Dropbox/ptables"

# <codecell>

pd.set_printoptions(max_colwidth=10000)

# <codecell>

for k in top_tfs.keys():
    if top_tfs[k] is not None:
        print k
        t = top_tfs[k].sort_index(by="pval", ascending=True)[0:30].merge(tf_target_counts, left_on="tf_name", right_index=True)
        e.write("<hr>")
        e.write("<h2>" + k + "</h2>")
        
        m = top_motifs[k].merge(mm9_motif_gene_counts, left_on="motif_name", right_index=True).sort_index(by="pval", ascending=True)[0:30].drop(["motif_name_x", "motif_name_y"], axis=1)
        m["lists"] = m.apply( lambda x: "<a href='" + hashlib.new('sha1', k + x["motif_name"]).hexdigest() + ".html" + "'>list</a>",  axis=1)
        t["lists"] = t.apply( lambda x: "<a href='" + hashlib.new('sha1', k + x["tf_name"]).hexdigest() + ".html" + "'>list</a>",  axis=1)

        e.write("<table>")
        e.write("<tr><th> top 30 overrepresented associations from CHEA </th> <th> top 30 over-represented tf binding motifs (SwissRegulon) </th></tr>")
        e.write("<tr><td>" + t.drop("tf_associations", axis=1).to_html(escape=False) + "</td>" + "<td style='padding-left: 25px'>" + m.drop("motif_occurrences", axis=1).to_html(escape=False) + "</td></tr></table>")

        for tf_name in t.tf_name:
            match_table_file = open( out_path + "/" + hashlib.new('sha1', k + tf_name).hexdigest() + ".html", "w")
            match_table_file.write( t.ix[tf_name, "tf_associations"].sort_index(by="symbol").to_html() )
            match_table_file.close()            
        
        for motif_name in m.index:
            match_table_file = open( out_path + "/" + hashlib.new('sha1', k + motif_name).hexdigest() + ".html", "w")
            match_table_file.write( m.ix[motif_name, "motif_occurrences"].sort_index(by="genename").to_html() )
            match_table_file.close()

# <codecell>

top_tfs.keys()

# <codecell>

top_tfs['[["cmp", ["6-OHDA, chronicSaline", "Ascorbate, chronicSaline"]], ["ct", "cp73"], ["dir", "up"]]']

# <codecell>

m.apply( lambda x: "<a href='" + hashlib.new('sha1', k + x["motif_name"]).hexdigest() + ".html" + "'>list</a>",  axis=1)

# <codecell>

e.close()

# <codecell>

top_motifs = top_motifs.sort_index(by="pval", ascending=True)

# <codecell>

top_motifs[ '[["cmp", ["6-OHDA, chronicLow", "6-OHDA, chronicSaline"]], ["ct", "cp101"], ["dir", "down"]]' ].sort_index(by="pval", ascending=True).drop("motif_occurrences", axis=1)

# <codecell>

k

# <codecell>

import hashlib

# <codecell>

table_lists = collections.OrderedDict()

# <codecell>

hashlib.new('sha1', k + "MAFB.p2").hexdigest()

# <codecell>

h.hexdigest()

# <codecell>

top_motifs[ k ].ix["MAFB.p2", "motif_occurrences"]

# <codecell>

patterns = cp_both_wide_info[ [c for c in pda.tm.m([("cmp"), 
          ("st", "pval"), 
         ("mc", "bh"), 
          ("tt", "welch ttest")], cp_both_wide_info.columns)] ]  < 0.10

# <codecell>

[c for c in pda.tm.m([("cmp"), 
          ("st", "pval"), 
          ("mc", "bh"), 
          ("tt", "welch ttest")], cp_both_wide_info.columns)]

# <codecell>

table_fc_threshold = log2(1.5)
cn_cp73_bh_ttest_pval = pda.tm.e([("cmp", ["6-OHDA, chronicSaline", "Ascorbate, chronicSaline"]), 
        ("ct", "cp73"), ("mc", "bh"), ("st", "pval"), ("tt", "welch ttest")])
cn_cp73_median_foldchange = pda.tm.e([  ("cmp", ["6-OHDA, chronicSaline", "Ascorbate, chronicSaline"]), 
        ("ct", "cp73"), ("st", "fc_medians")])

cp73_dopamine_depletion_up = (cp_both_wide_info.select(
    lambda x: cp_both_wide_info.ix[x, cn_cp73_bh_ttest_pval] < 0.10
    and cp_both_wide_info.ix[x, cn_cp73_median_foldchange] >= table_fc_threshold
))[["probe_id", "symbol", "gene_name", 
    cn_cp73_bh_ttest_pval,
    cn_cp73_median_foldchange
    ]].sort_index(by=cn_cp73_median_foldchange, ascending=False)

# <codecell>

cn_cp73_chronicHigh_bh_ttest_pval = pda.tm.e([  ("cmp", ["6-OHDA, chronicHigh", "6-OHDA, chronicSaline"]),
            ("ct", "cp73"),
            ("mc", "bh"),
            ("st", "pval"),
            ("tt", "welch ttest")
        ])

cn_cp73_chronicHigh_foldchange = pda.tm.e([  
            ("cmp", ["6-OHDA, chronicHigh", "6-OHDA, chronicSaline"]),
            ("ct", "cp73"),
            ("st", "fc_medians")
        ])

cp73_chronicHigh_up = (cp_both_wide_info.select(
    lambda x: (cp_both_wide_info.ix[x, cn_cp73_chronicHigh_bh_ttest_pval] < 0.10)
    and cp_both_wide_info.ix[x, cn_cp73_chronicHigh_foldchange] >= table_fc_threshold
))[["symbol", cn_cp73_chronicHigh_bh_ttest_pval, cn_cp73_chronicHigh_foldchange]]

cp73_chronicHigh_down = (cp_both_wide_info.select(
    lambda x: (cp_both_wide_info.ix[x, cn_cp73_chronicHigh_bh_ttest_pval] < 0.10)
    and cp_both_wide_info.ix[x, cn_cp73_chronicHigh_foldchange] <= -table_fc_threshold
))[["symbol", cn_cp73_chronicHigh_bh_ttest_pval, cn_cp73_chronicHigh_foldchange]]

# <codecell>

[c for c in pda.tm.m([("cmp"), 
          ("st", "pval"), 
          ("mc", "bh"), 
          ("tt", "welch ttest")], cp_both_wide_info.columns)]

# <codecell>

patterns

# <codecell>

patterns.columns = [[pda.tm.e(val) for (t, val) in pda.tm.d( c ) if t == "cmp"][0] for c in patterns.columns]

# <codecell>

def patternGroup(x):
    r = patterns.ix[ x, :]
    return int("".join([str(int(a)) for a in r]), 2)

# <codecell>

g = patterns.groupby(patternGroup)

# <codecell>

len(g.groups.items())

# <codecell>

for (k, v) in g.groups.items():
    print k, len(v)

# <codecell>

figsize(10,10)
imshow( g.get_group(656).as_matrix(), interpolation="nearest", cmap=get_cmap("gray"))

# <codecell>

def uniqueSym(symbolSeries):
    symbolSeries = symbolSeries.fillna("-")
    r = set(symbolSeries)
    r.discard(nan)
    r.discard("-")
    return(r)

# <codecell>

targets = cz.target.unique()
tfs = cz.tf.unique()

# <codecell>

chea = pd.read_table("/data/adrian/Dropbox/Data/chea/chea-background.csv", header=None, 
                     names=["chea_id", "tf", "tf_pmid", "target", 
                            "pmid", "exp_type", "cell_type", "organism", "date"], sep=",")

# <codecell>

chea = chea.astype('unicode')

# <codecell>

czm = zeros( [len(targets), len(tfs)] )
target_index = dict( (a[1], a[0]) for a in enumerate(targets) )
tf_index = dict( (a[1], a[0]) for a in enumerate(tfs) )

# <codecell>

pandasql.sqldf("select tf, count(*) c from cz group by tf order by c desc", locals())[0:10]

# <codecell>

for i in cz.index:
    czm[target_index[cz.ix[i, "target"]], tf_index[cz.ix[i, "tf"]]] = 1

# <codecell>

czm_df = pandas.DataFrame(data=czm, index=target_index, columns=tf_index)

# <codecell>


# <codecell>


# <codecell>

import IPython

# <codecell>

IPython.display.HTML( cz[0:5].to_html() )

# <codecell>

cp73_dopamine_depletion_up

# <codecell>

import itertools

# <codecell>

177 * 177 * 177

# <codecell>

len( cz.groupby("target").groups.items() )

# <codecell>

len(  list( itertools.combinations( cz.ix[g, "tf"].unique(), 3) ) )

# <codecell>

def countTFcombos( genegroup, combination_size ):
    z = [a.upper() for a in set( uniqueSym( genegroup.symbol ))]
    z_set = set(z)
    cz= chea.select( lambda x: chea.ix[x, "target"] in z_set)
    
    print(len(cz.index))
    
    pair_counts = {}
    for (target_group, g) in cz.groupby("target").groups.items():
        group_tfs = cz.ix[g, "tf"].unique()
        group_tfs.sort()
#        for combo in itertools.combinations( group_tfs , combination_size):
#            pair_counts[combo] = pair_counts.setdefault(combo, 0) + 1
        for tf in group_tfs:
            pair_counts[tf] = pair_counts.setdefault(tf, 0) + 1
    result = pd.DataFrame( pair_counts.items(), columns=["tf", "count"]).sort_index(by="count", ascending=False) 
    result["total_genes_in_group"] = len(z)
    #ret
    return result

# <codecell>

def countMotifCombos( genegroup, combination_size ):
    z = [a for a in set( uniqueSym( genegroup.symbol ))]
    z_set = set(z)
    cz= mm9_gene_motifs.select( lambda x: mm9_gene_motifs.ix[x, "genename"] in z_set)
    
    print(len(cz.index))
    
    pair_counts = {}
    for (target_group, g) in cz.groupby("genename").groups.items():
        group_motifs = cz.ix[g, "motif_name"].unique()
        group_motifs.sort()
#        for combo in itertools.combinations( group_tfs , combination_size):
#            pair_counts[combo] = pair_counts.setdefault(combo, 0) + 1
        for motif_name in group_motifs:
            pair_counts[motif_name] = pair_counts.setdefault(motif_name, 0) + 1
    result = pd.DataFrame( pair_counts.items(), columns=["motif_name", "count"]).sort_index(by="count", ascending=False) 
    result["total_genes_in_group"] = len(z)
    #ret
    return result



# <codecell>

def getTFMatches( genegroup, combination_size=1):
    genegroup["upper_sym"] = [a.upper() if isinstance(a, str) else "-" for a in genegroup.symbol ]
    cz = chea.merge( genegroup, left_on="target", right_on="upper_sym")
    
    total_genes_in_group = len( uniqueSym(genegroup.symbol) )
    
    print(len(cz.index))
    result = []
    for k, z in cz.groupby("tf"):
        result.append( { "tf_name" : k,
                         "count" : len(uniqueSym(z.symbol)),
                         "total_genes_in_group" : total_genes_in_group,
                         "tf_associations" : z
                         })
    result = pd.DataFrame(result)
    result.index = result.tf_name
    return result

# <codecell>

def getMotifMatches( genegroup, combination_size ):
    cz= mm9_gene_motifs.merge(genegroup, left_on="genename", right_on="symbol") 
    
    total_genes_in_group = len( uniqueSym(genegroup.symbol) )
    
    print(len(cz.index))
    
    result = []
    for k, z in cz.groupby("motif_name"):
        result.append( { "motif_name"  : k,
                         "count" : len(uniqueSym(z.symbol)),
                         "total_genes_in_group" : total_genes_in_group,
                         "motif_occurrences": z
                        }  )
        
    result = pd.DataFrame(result)
    result.index = result.motif_name
    return result

# <codecell>

r = getTFMatches( cp73_chronicHigh_up, 1)

# <codecell>

r.ix["AHR","tf_associations"]

# <codecell>

r.index = r.motif_name

# <codecell>

pd.options.display.max_columns=100

# <codecell>

r.ix["bHLH_family.p2","motif_occurrences"].

# <codecell>

r.ix[row, "total_genes_in_group"]

# <codecell>

r = top_motifs[k]

# <codecell>

r.sort_index(by="pval", ascending=True).index

# <codecell>

table_text = "<table>"
for row in r.sort_index(by="pval", ascending=True).index[0:30]:
    print row
    table_text += "<tr>"
    table_text += "<td> <a onclick='$(\"#detail_%d\").toggle();'><b>+</b></a> </td>" % row
    table_text += "<td>" + r.ix[row, "motif_name"] + "</td>"
    table_text += "<td>" + str(r.ix[row, "count"]) + "</td>"
    table_text += "<td>" + str(r.ix[row, "pval"]) + "</td>"
    table_text += "<td>" + str(r.ix[row, "total_genes_in_group"]) + "</td>"
    table_text += "</tr>"
    table_text += "<tr><td colspan=4><div id='detail_%d' style='height: 200px; width=400px; overflow:auto; display: none'>" % row 
    table_text += r.ix[row, "motif_occurrences"].to_html() + "</div></td></tr>"
table_text += "</table>"

# <codecell>

f = open("/data/adrian/Dropbox/motif_table_aug22.html", "w")

# <codecell>

f.write(table_text)

# <codecell>

r.ix[1, "motif_occurrences"].sort_index(by=r.ix[1, "motif_occurrences"].columns[8], ascending=False)[0:50]

# <codecell>

help( pd.options.display.chop_threshold )

# <codecell>

r.ix[1, "motif_occurrences"][0:5]

# <codecell>

r.ix[1, "motif_occurrences"][0:5]

# <codecell>

IPython.display.HTML( c.sort_index(by=c.columns[8], ascending=False).to_html() )

# <codecell>

for k, g in cz.groupby("tf"):
    print k, len(g.target.unique())

# <codecell>

cz.groupby("motif_name")

# <codecell>

countMotifCombos( cp73_chronicHigh_up, 1)[0:20]

# <codecell>

test = countTFcombos( cp73_chronicHigh_up, 1)

# <codecell>

test = pd.DataFrame( countTFcombos( cp73_chronicHigh_up, 1).items(), columns=["tf", "count"]).sort_index(by="count", ascending=False) 

# <codecell>

test[0:10].merge(tf_target_counts, left_on="tf", right_index=True)[0:10]

# <codecell>

test.merge(tf_target_counts, left_on="tf", right_index=True)[0:10]

# <codecell>

len(z)

# <codecell>

tf_target_counts = []
for (k, g) in chea.groupby("tf"):
    tf_target_counts.append( { "tf" : k, "chea_target_count" : len( uniqueSym( g.target )) } )
tf_target_counts = pd.DataFrame.from_dict(tf_target_counts)
tf_target_counts.index = tf_target_counts.tf

# <codecell>

mm9_motif_gene_counts = []
for (k, g) in mm9_gene_motifs.groupby("motif_name"):
    mm9_motif_gene_counts.append( { "motif_name" : k, "motif_gene_count" : len(g.genename.unique()) } )
mm9_motif_gene_counts = pd.DataFrame.from_dict( mm9_motif_gene_counts )
mm9_motif_gene_counts.index = mm9_motif_gene_counts.motif_name

# <codecell>

pd.set_printoptions(max_columns=100, max_rows=100)

# <codecell>

IPython.display.HTML( mm9_motif_gene_counts.sort_index(by="motif_gene_count", ascending=False).to_html() )

# <codecell>

tf_target_counts.ix["CREM", :]

# <codecell>

down_2 = pd.DataFrame( countTFcombos(cp73_chronicHigh_down).items(), 
             columns=["pair", "c"] ).sort_index(by="c", ascending=False)

# <codecell>

up_2 = pd.DataFrame( countTFcombos(cp73_chronicHigh_up).items(), 
             columns=["pair", "c"] ).sort_index(by="c", ascending=False)

# <codecell>

down_2["frac"] = down_2["c"] / float(len(cp73_chronicHigh_down.index))

# <codecell>

up_2["frac"] = up_2["c"] / float(len(cp73_chronicHigh_up.index))

# <codecell>

both_3 = up_3.merge(down_3, left_on="pair", right_on="pair", how="outer", suffixes=("_up","_down")).fillna(0)

# <codecell>

both_2 = up_2.merge(down_2, left_on="pair", right_on="pair", how="outer", suffixes=("_up","_down")).fillna(0)

# <codecell>

both_3["diff"] = both_3["frac_up"] - both_3["frac_down"] 

# <codecell>

both_2["diff"] = both_2["frac_up"] - both_2["frac_down"] 

# <codecell>

both_2.sort_index(by="diff", ascending=False)[0:20] 

# <codecell>

both_3.sort_index(by="diff", ascending=True)[0:20] 

# <codecell>

pd.DataFrame( pair_counts.items(), columns=["pair", "c"] ).sort_index(by="c", ascending=False)[0:20]

# <codecell>

pair_counts.items()

# <codecell>

len( list( itertools.combinations( cz.tf.unique(), 2) ) )

# <codecell>

cz.groupby("tf").count().sort_index(by="chea_id", ascending=False)[0:20]

# <codecell>

alib.plots.clusterHeatmap( czm_df, "", None, None, 
                            cluster_columns=True, 
                            cluster_rows=True, 
                            distmethod='jaccard')

